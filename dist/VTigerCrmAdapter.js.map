{"version":3,"sources":["../src/VTigerCrmAdapter.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAGA,IAAM,YAAY,QAAQ,gCAAR,CAAlB,C;AACA,IAAM,WAAW,QAAQ,WAAR,CAAjB;;IAEa,yB,WAAA,yB;;;AACT,uCAAY,SAAZ,EAAuB,OAAvB,EAAgC,QAAhC,EAAyC;AAAA;;AAAA,iHAC/B,OAD+B;;AAErC,cAAK,SAAL,GAAiB,SAAjB;AACA,cAAK,QAAL,GAAgB,QAAhB;AAHqC;AAIxC;;;EAL0C,K;;IAQlC,gB,WAAA,gB;AAET,8BAAY,QAAZ,EAAsB,QAAtB,EAAgC,SAAhC,EAA2C;AAAA;;AAEvC,aAAK,QAAL,GAAgB,QAAhB;AACA,aAAK,SAAL,GAAiB,SAAjB;AACA,aAAK,YAAL,GAAoB,EAApB;;AAEA,aAAK,SAAL,GAAiB,IAAI,UAAU,UAAd,EAAjB,C;AACA,aAAK,SAAL,CAAe,SAAf,CAAyB,QAAzB,GAAoC,QAApC;;;;;;;;;;;;;;AAcH;;;;uCAEc;AACX,gBAAM,kBAAkB,IAAxB;AACA,mBAAO,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAU,MAAV,EAAmB;AAClC,oBAAI,gBAAgB,YAApB,EAAiC;AAAE,4BAAQ,gBAAgB,YAAxB;AAAuC,iBAA1E,MAAgF;AAC5E,oCAAgB,SAAhB,CAA0B,wBAA1B,CAAmD,gBAAgB,QAAnE,EAA6E,UAAC,GAAD,EAAM,IAAN,EAAY,QAAZ,EAAwB;AACjG,4BAAI,GAAJ,EAAS;AACL,mCAAO,OAAQ,IAAI,yBAAJ,CAA+B,eAA/B,EAAgD,+BAAhD,EAAiF,GAAjF,CAAR,CAAP;AACH;AACD,4BAAI,CAAC,SAAS,IAAT,CAAc,OAAnB,EAA4B;AACxB,mCAAO,OAAQ,IAAI,yBAAJ,CAA+B,eAA/B,EAAgD,8BAAhD,EAAgF,SAAS,IAAT,CAAc,KAAd,CAAoB,OAApG,CAAR,CAAP;AACH;;AAED,4BAAM,iBAAiB,SAAS,IAAT,CAAc,MAAd,CAAqB,KAA5C;AACA,gCAAQ,GAAR,CAAY,iBAAZ,EAA+B,cAA/B;;AAEA,wCAAgB,SAAhB,CAA0B,kBAA1B,CAA6C,gBAAgB,QAA7D,EAAuE,SAAS,GAAT,CAAa,iBAAiB,gBAAgB,SAA9C,EAAyD,QAAzD,EAAvE,EAA4I,UAAC,GAAD,EAAM,IAAN,EAAY,QAAZ,EAAwB;AAChK,gCAAI,GAAJ,EAAS;AACL,uCAAO,OAAQ,IAAI,yBAAJ,CAA+B,OAA/B,EAAwC,+BAAxC,EAAyE,GAAzE,CAAR,CAAP;AACH;;AAED,gCAAI,CAAC,SAAS,IAAT,CAAc,OAAnB,EAA4B;AACxB,uCAAO,OAAQ,IAAI,yBAAJ,CAA+B,OAA/B,EAAwC,mBAAxC,EAA6D,SAAS,IAAT,CAAc,KAAd,CAAoB,OAAjF,CAAR,CAAP;AACH;;AAED,oCAAQ,GAAR,CAAY,eAAZ,EAA6B,SAAS,IAAT,CAAc,MAAd,CAAqB,WAAlD;AACA,oCAAQ,SAAS,IAAT,CAAc,MAAd,CAAqB,WAA7B;AAEH,yBAZD,E;AAaH,qBAxBD,E;AAyBH;AAAC,aA3BC,CAAP;AA4BH,S;;;;qCAaY,W,EAAY;AACrB,gBAAM,kBAAkB,IAAxB;;AAEA,mBAAO,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAU,MAAV,EAAmB;AAClC,oBAAI,CAAC,gBAAgB,YAArB,EAAmC,OAAO,IAAI,yBAAJ,CAA8B,OAA9B,EAAuC,4BAAvC,CAAP;AACnC,gCAAgB,SAAhB,CAA0B,iBAA1B,CAA6C,gBAAgB,YAA7D,EAA2E,WAA3E,EAAwF,UAAC,GAAD,EAAM,IAAN,EAAY,QAAZ,EAAuB;AAC3G,wBAAI,GAAJ,EAAS;AACL,+BAAO,OAAQ,IAAI,yBAAJ,CAA+B,OAA/B,EAAwC,+BAAxC,EAAyE,GAAzE,CAAR,CAAP;AACH;;AAED,wBAAI,CAAC,SAAS,IAAT,CAAc,OAAnB,EAA4B;AACxB,+BAAO,OAAQ,IAAI,yBAAJ,CAA+B,OAA/B,EAAwC,0BAAxC,EAAoE,SAAS,IAAT,CAAc,KAAd,CAAoB,OAAxF,CAAR,CAAP;AACH;;AAED,4BAAQ,SAAS,IAAT,CAAc,MAAtB,E;AACH,iBAVD;AAWH,aAbM,CAAP;AAcH;;;sDAE6B,e,EAAgC;AAAA,gBAAf,QAAe,yDAAN,KAAM;;;;;;AAK1D,gBAAM,kBAAkB,IAAxB;AACA,gBAAM,cAAc,kCAAkC,iBAAiB,sBAAjB,CAAwC,eAAxC,EAAyD,QAAzD,CAAlC,GAAuG,GAA3H;;AAEA,mBAAO,gBAAgB,YAAhB,GACE,IADF,CACO,UAAC,aAAD,EAAiB;AACnB,gCAAgB,YAAhB,GAA+B,aAA/B;AACH,aAHF,EAIE,IAJF,CAIQ,YAAI;AAAE,uBAAO,gBAAgB,YAAhB,CAA6B,WAA7B,CAAP;AAAiD,aAJ/D,CAAP;AAKH,S;;;;oDAE2B,I,EAAK;AAC7B,gBAAM,kBAAkB;AACpB,0BAAU,IADU;AAEpB,2BAAW,IAFS;AAGpB,uBAAO;AAHa,aAAxB;;AAMD,mBAAO,KAAK,6BAAL,CAAmC,eAAnC,EAAoD,IAApD,CAAP;AACF,S;;;;wCAEe,S,EAAU;AACtB,mBAAO,KAAK,6BAAL,CAAmC,EAAE,IAAI,SAAN,EAAnC,CAAP;AACH;;;+CAzD6B,O,EAAS,Q,EAAS;AAC5C,gBAAI,cAAc,EAAlB;AACA,iBAAI,IAAI,GAAR,IAAe,OAAf,EAAuB;AACnB,oBAAI,QAAQ,cAAR,CAAuB,GAAvB,CAAJ,EAAgC;AAC5B,wBAAI,WAAJ,EAAiB,eAAe,MAAM,QAAN,GAAiB,GAAhC;AACjB,mCAAe,MAAM,SAAN,GAAkB,QAAQ,GAAR,CAAlB,GAAiC,GAAhD;AACH;AACJ;AACD,mBAAO,WAAP;AACH","file":"VTigerCrmAdapter.js","sourcesContent":["/**\r\n * Created by OliverJaegle on 08.06.2016.\r\n */\r\nconst VTigerCrm = require('./vtiger_consumer_swagger/src/'); // See note below*.\r\nconst CryptoJS = require('crypto-js');\r\n\r\nexport class VTigerCrmAdapterException extends Error{\r\n    constructor(operation, message, previous){\r\n        super(message);\r\n        this.operation = operation;\r\n        this.previous = previous;\r\n    }\r\n}\r\n\r\nexport class VTigerCrmAdapter {\r\n\r\n    constructor(basePath, username, accesskey) {\r\n\r\n        this.username = username;\r\n        this.accesskey = accesskey;\r\n        this.sessionToken = '';\r\n\r\n        this.vTigerApi = new VTigerCrm.DefaultApi(); // Allocate the API class we're going to use.\r\n        this.vTigerApi.apiClient.basePath = basePath;\r\n\r\n/*          We can't login in the constructor as a consumer might immediately issue a subsequent request.\r\n            Thus, all the resolvers of the login-Promise need to buffer the result in order to take advantage of existing\r\n            session tokens\r\n\r\n            this.loginPromise(this.username, this.accessKey)\r\n            .then((result)=>{\r\n                this.sessionToken = result\r\n            })\r\n            .catch((err)=>{\r\n                console.error(err.operation, err.message, err.previous.toString());\r\n                throw err;\r\n            });*/\r\n    }\r\n\r\n    loginPromise() {\r\n        const adapterInstance = this;\r\n        return new Promise((resolve, reject)=>{\r\n            if (adapterInstance.sessionToken){ resolve(adapterInstance.sessionToken) } else {\r\n                adapterInstance.vTigerApi.operationgetchallengeGet(adapterInstance.username, (err, data, response)=> {\r\n                    if (err) {\r\n                        return reject( new VTigerCrmAdapterException( 'GET_CHALLENGE', 'Couldn\\'t execute webservice:', err ));\r\n                    }\r\n                    if (!response.body.success) {\r\n                        return reject( new VTigerCrmAdapterException( 'GET_CHALLENGE', 'Couldn\\'t receive challenge:', response.body.error.message ));\r\n                    }\r\n\r\n                    const challengeToken = response.body.result.token;\r\n                    console.log('CHALLENGE_TOKEN', challengeToken);\r\n\r\n                    adapterInstance.vTigerApi.operationloginPost(adapterInstance.username, CryptoJS.MD5(challengeToken + adapterInstance.accesskey).toString(), (err, data, response)=> {\r\n                        if (err) {\r\n                            return reject( new VTigerCrmAdapterException( 'LOGIN', 'Couldn\\'t execute webservice:', err ));\r\n                        }\r\n\r\n                        if (!response.body.success) {\r\n                            return reject( new VTigerCrmAdapterException( 'LOGIN', 'Couldn\\'t log in:', response.body.error.message));\r\n                        }\r\n\r\n                        console.log('SESSION_TOKEN', response.body.result.sessionName);\r\n                        resolve(response.body.result.sessionName);\r\n\r\n                    }); //operationLoginPost\r\n                }); //operationChallengeGet\r\n            }})\r\n    }//loginPromise\r\n\r\n    static contactSkeletonToWhere(contact, operator){\r\n        let whereClause = '';\r\n        for(let key in contact){\r\n            if (contact.hasOwnProperty(key)){\r\n                if (whereClause) whereClause += ' ' + operator + ' ';\r\n                whereClause += key + \" LIKE '\" + contact[key] + \"'\";\r\n            }\r\n        }\r\n        return whereClause;\r\n    }\r\n\r\n    queryPromise(queryString){\r\n        const adapterInstance = this;\r\n\r\n        return new Promise((resolve, reject)=>{\r\n            if (!adapterInstance.sessionToken) reject(new VTigerCrmAdapterException('QUERY', 'No session token for query'));\r\n            adapterInstance.vTigerApi.operationqueryGet( adapterInstance.sessionToken, queryString, (err, data, response)=>{\r\n                if (err) {\r\n                    return reject( new VTigerCrmAdapterException( 'QUERY', 'Couldn\\'t execute webservice:', err ));\r\n                }\r\n\r\n                if (!response.body.success) {\r\n                    return reject( new VTigerCrmAdapterException( 'QUERY', 'Couldn\\'t execute query:', response.body.error.message));\r\n                }\r\n\r\n                resolve(response.body.result); //might be initial\r\n            })\r\n        })\r\n    }\r\n\r\n    findContactsBySkeletonPromise(contactSkeleton, operator='AND'){\r\n        /**\r\n         * Operator defines how the properties of the contact skeleton are to be combined.\r\n         * Possible values ['AND', 'OR']\r\n         */\r\n        const adapterInstance = this;\r\n        const queryString = \"select * from Contacts where \" + VTigerCrmAdapter.contactSkeletonToWhere(contactSkeleton, operator) + \";\";\r\n\r\n        return adapterInstance.loginPromise()\r\n                .then((sessionHandle)=>{\r\n                    adapterInstance.sessionToken = sessionHandle;\r\n                })\r\n                .then( ()=>{ return adapterInstance.queryPromise(queryString)});\r\n    } //findContactsBySkeletonPromise\r\n\r\n    findContactsFulltextPromise(text){\r\n        const contactSkeleton = {\r\n            lastname: text,\r\n            firstname: text,\r\n            email: text\r\n        };\r\n\r\n       return this.findContactsBySkeletonPromise(contactSkeleton, 'OR');\r\n    } //findContactsFulltextPromise\r\n\r\n    findContactById(contactId){\r\n        return this.findContactsBySkeletonPromise({ id: contactId });\r\n    }\r\n}\r\n"]}